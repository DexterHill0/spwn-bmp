extract import "utils.spwn"

PIXEL_OBJ_ID = null

_error = (message) {
	throw "[ERROR]: {}".fmt([message])
}


type @chunk
impl @chunk {
	new: (c_data: @data, index: @number) {
		let rdata = c_data

		c_len = rdata.read(4).raw().bytes_to_int()

		let c_type = null
		let data = null
		let crc = null

		if c_len > 0 {
			c_type = rdata.read(4).raw().bytes_to_str()
			data = rdata.read(c_len)
			crc = rdata.read(4).raw().bytes_to_int()
		}
		
		return @chunk::{
			index,
			len: c_len,
			ctype: c_type,
			data,
			crc,
		}
	},
}

type @colour
impl @colour {
	COLOUR_MODES: @enum::new(
		["GRAYSCALE", "RGB", "PLTE", "GRAYSCALE_A", "RGB_A"], 
		[0, 2, 3, 4, 6]
	),

	BIT_DEPTHS: {
		GRAYSCALE: [1, 2, 4, 8, 16],
		RGB: [8, 16],
		PLTE: [1, 2, 4, 8],
		GRAYSCALE_A: [8, 16],
		RGB_A: [8, 16]
	},

	new: (mode: @number, bit_depth: @number) {
		if !(@colour::COLOUR_MODES has mode) {
			_error("Error parsing PNG (invalid colour mode: {})".fmt([mode]))
		}

		colour_mode = @colour::COLOUR_MODES..mode

		if @colour::BIT_DEPTHS[colour_mode].index(bit_depth) == null {
			_error("Error parsing PNG (invalid bit depth {} for colour {})".fmt([bit_depth, colour_mode]))
		}

		return @colour::{
			mode,
			depth: bit_depth,
		}
	}
}

type @png
impl @png {
	MAGIC_BYTES: [137, 80, 78, 71, 13, 10, 26, 10],

	//The only chunks that are important to us
	CHUNK_TYPES: @enum::new(["IDAT", "IHDR"]),

	_validate_png: (self) {
		MAGIC_LENGTH = @png::MAGIC_BYTES.length

		if @png::MAGIC_BYTES != self.raw.read(MAGIC_LENGTH).raw() {
			_error("Invalid PNG file! (incorrect magic bytes)")
		}
	},

	_get_chunks: (self) {
		if self.chunks.length > 0 {
			_error("Cannot read past end of PNG! (_get_chunks called more than once)")
		}

		//Skip the magic bytes since they were already checked
		let i = 0

		while true {
			chunk_length = self.raw.read(4).raw().bytes_to_int()
			//Move back 4 to cancel out that read
			self.raw.move(-4)
		
			//Add 4 to skip the length of the chunk type data
			chunk = @chunk::new(self.raw.read(12 + chunk_length), i)

			if @png::CHUNK_TYPES..chunk.ctype != null {
				self.chunks.push(chunk)
			}

			if self.raw.is_eof() {
				break
			}

			i++
		}

		//Clear the old data since it is in chunks now
		self.raw = null
	},

	_parse: (self) {
		self._validate_png()
		self._get_chunks()

		let chunk_zero = self.chunks[0]

		width = chunk_zero.data.read(4).raw().bytes_to_int()
		height = chunk_zero.data.read(4).raw().bytes_to_int()

		if width == 0 || height == 0 {
			_error("Error parsing PNG! (width &/ height must be greater than 0)")
		}

		self.hdr.w = width
		self.hdr.h = height

		//Skip bit depth for now - might need later though
		bit_depth = chunk_zero.data.read(1).raw()[0]

		colour_type = @colour::new(chunk_zero.data.read(1).raw()[0], bit_depth)
		compr_method = chunk_zero.data.read(1).raw()[0]

		self.hdr.col = colour_type

		//TODO: IDAT (de)compression algorithm
	},

	new: (data: @data) {
		return @png::{
			//hdr for header
			hdr: {
				//width, height
				w: null,
				h: null,
				col: null,
				comp: null,
			},
			raw: data,
			//c for chunks
			chunks: [],
		}
	}
}


//Reads and parses the png file
parse_png = (
	#[desc("Path to the file")]
	file,
) {
    let data = @data::new($.readfile(file, "bin"))

	let png = @png::new(data)
	png._parse()

	return png
}



png_to_objects = (
	#[desc("Starting x offset for the pixels. Default is +10 (from 0,0)")]
	start_x = 10,
	#[desc("Starting y offset for the pixels. Default is +100 (from 0,0)")]
	start_y = 100,

	#[desc("Starting group for the objects. Default is 1")]
	start_group = 1,
	#[desc("Enables/Disables adding groups to all the pixels. Default is false")]
	add_groups = false,
	#[desc("The function that generates the group value")]
	group_factory = null,

	#[desc("Instead of using 1 unique colour for every pixel, use 1 colour and hue shift to get the right colour. Default is false")]
	use_hue_shift = false,
	#[desc("Starting hue offset. Default is 0")]
	hue_offset = 0,

	#[desc("The size of the individual pixels. Default is 1")]
	pixel_scale = 1,
	#[desc("The number of pixels placed per pixel in the image (n:1). Default is 1")]
	pixel_density = 1,

	#[desc("Enables/Disables glow on the pixels. Default is false")]
	show_glow = false,
) {
	//Validation for the arguments
	if start_x <= 0 {
		_error("start_x must be greater than 0!")
	}
	if start_y <= 0 {
		_error("start_y must be greater than 0!")
	}

	if start_group <= 0 {
		_error("start_group must be greater than 0!")
	}

	if hue_offset < 0 || hue_offset > 180 {
		_error("hue_offset must be between 0 and 180!")
	}

	if pixel_scale < 0.1 || pixel_scale > 4 {
		_error("pixel_scale must be between 0.1 and 4!")
	}
}

parse_png("test.png")
