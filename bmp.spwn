extract import "utils.spwn"

PIXEL_OBJ_ID = null

_error = (message) {
	throw "[ERROR]: {}".fmt([message])
}

type @colour
impl @colour {

	new: (r: @number, g: @number, b: @number, a: @number = 255) {
		return @colour::{
			r, g, b, a: (a / 255)
		}
	}
}


//Moved into separate classes since it's just a bit neater
type @bmp_fhdr
impl @bmp_fhdr {
	SIZE: 14,

	new: (data: @data) {
		let data = data

		let file_header = data.read(@bmp_fhdr::SIZE)
		
		bfType = file_header.read(2).raw().bytes_to_str()
		bfSize = file_header.read(4).raw().bytes_to_int()
		
		//Skips reserved
		file_header.move(4)

		bfOffBits = file_header.read(4).raw().bytes_to_int()

		return @bmp_fhdr::{
			size: @bmp_fhdr::SIZE,
			bfType,
			bfSize,
			reserved1: 0,
			reserved2: 0,
			bfOffBits,
		}
	}
}

// https://upload.wikimedia.org/wikipedia/commons/c/c4/BMPfileFormat.png
// https://github.com/python-pillow/Pillow/blob/master/src/PIL/BmpImagePlugin.py
// ^^^ very helpful :)
type @bmp_ihdr
impl @bmp_ihdr {
	
	BIT2MODE: @enum::new([
		["P", "P;1"],
		["P", "P;4"],
		["P", "P;8"],
		["RGB", "BGR;15"],
		["RGB", "BGR"],
		["RGB", "BGRX"]
	], [1, 4, 8, 16, 24, 32]),

	SUPPORTED: @enum::new([
		[
			[16711680, 65280, 255, 0],
			[16711680, 65280, 255, 4278190080],
			[255, 65280, 16711680, 4278190080],
			[0, 0, 0, 0],
			[4278190080, 16711680, 65280, 0],
		],	
		[[16711680, 65280, 255]],
		[[63488, 2016, 31], [31744, 992, 31]],
	], [32, 24, 16]),

	MASK_MODES: {
		// -> _<bitCount>_<SUPPORTED-arrayIndex>
		_32_0: "BGRX",
		_32_1: "XBGR",
		_32_2: "RGBA",
		_32_3: "BGRA",
		_32_4: "BGRA",
		_24_0: "BGR",	
		_16_0: "BGR;16",
		_16_1: "BGR;15",
	},

	COMPRESSIONS: @enum::new(["RAW", "RLE8", "RLE4", "BITFIELDS"]),

	new: (data: @data) {
		let data = data

		size = data.read(4).raw().bytes_to_int()

		let info_header = data.read(size - 4)

		//Oops >.<
		let biWidth = null; let biHeight = null; let biPlanes = null; let biBitCount = null; let biCompression = null; let biPalettePadding = null;
		let biYFlip = null; let biDirection = null; let biImageSize = null; let biPixPerMeter = null; let biColors = null; let biDpi = [];

		//IBM OS/2 Bitmap v1
		if size == 12 {
			biWidth = info_header.read(2).raw().bytes_to_int()
			biHeight = info_header.read(2).raw().bytes_to_int()
			biPlanes = info_header.read(2).raw().bytes_to_int()
			biBitCount = info_header.read(2).raw().bytes_to_int()
			biCompression = @bmp::COMPRESSIONS.."RAW"
			biPalettePadding = 3

		}
		//Windows Bitmap v2 to v5
		else if [40, 64, 108, 124] has size {
			biYFlip = (info_header.raw()[7] == 255)
			biDirection = 1 if biYFlip else -1

			biWidth = info_header.read(4).raw().bytes_to_int()
			biHeight = info_header.read(4).raw().bytes_to_int()
			biHeight = biHeight if !biYFlip else 2 ** 32 - biHeight

			biPlanes = info_header.read(2).raw().bytes_to_int()
			biBitCount = info_header.read(2).raw().bytes_to_int()
			biCompression = info_header.read(4).raw().bytes_to_int()
			biImageSize = info_header.read(4).raw().bytes_to_int()
			biPixPerMeter = [
				info_header.read(4).raw().bytes_to_int(),
				info_header.read(4).raw().bytes_to_int(),
			]

			biColors = info_header.read(4).raw().bytes_to_int()
			biPalettePadding = 4

			for m in biPixPerMeter {
				biDpi.push($.floor(m / 39.3701 + 0.5))
			}

		}
		else {
			_error("Error parsing BMP! (unknown header type {})".fmt([size]))
		}

		biColors = biColors if biColors != 0 else 1.s_left(biBitCount)
		
		let masks = {}
		let biRGBMask = []
		let biRGBAMask = []

		if @bmp_ihdr::COMPRESSIONS.."BITFIELDS" == biCompression {
			_m = ["r_mask", "g_mask", "b_mask", "a_mask"]
			if size >= 52 {
				info_header.move(4)
				for i in 0.._m.length {
					masks.set(_m[i], info_header.read(4).raw().bytes_to_int())
				}
			} 
			else {
				masks["a_mask"] = 0
				
				//Leave out a_mask
				for m in _m[0:3] {
					masks.set(m, data.read(4).raw().bytes_to_int())
				}
			}

			biRGBAMask = [
				masks["r_mask"],
				masks["g_mask"],
				masks["b_mask"],
				masks["a_mask"],
			]
			biRGBMask = [
				masks["r_mask"],
				masks["g_mask"],
				masks["b_mask"],
			]
		}

		mask_key = (bit, ind) {
			return "_{}_{}".fmt([bit, ind])
		}

		modes = @bmp_ihdr::BIT2MODE..biBitCount
		let biMode = modes[0]
		let raw_mode = modes[1]
		
		if @bmp_ihdr::COMPRESSIONS.."BITFIELDS" == biCompression {
			if @bmp_ihdr::SUPPORTED has biBitCount {
				if biBitCount == 32 && ((@bmp_ihdr::SUPPORTED..biBitCount) has biRGBAMask) {
					raw_mode = @bmp_ihdr::MASK_MODES[mask_key(biBitCount, (@bmp_ihdr::SUPPORTED..biBitCount).index(biRGBAMask))]
					biMode = "RGBA" if raw_mode has "A" else biMode
				}
				else if [24, 16] has biBitCount && ((@bmp_ihdr::SUPPORTED..biBitCount) has biRGBMask) {
					raw_mode = @bmp_ihdr::MASK_MODES[mask_key(biBitCount, (@bmp_ihdr::SUPPORTED..biBitCount).index(biRGBMask))]
				}
				else {
					_error("Error parsing BMP! (uknown bitfields layout)")
				}
			}
			else {
				_error("Error parsing BMP! (uknown bitfields layout)")
			}
		}
		else if @bmp_ihdr::COMPRESSIONS.."RAW" == biCompression {
			// According to PIL this branch checks a variable called "header" to see if it is `22`
			// but "header" is never provided as an argument to the func so I dont think this branch ever executes
			// https://github.com/python-pillow/Pillow/blob/fb0aad5abdab9027cf8f02082ca4dab921692b79/src/PIL/BmpImagePlugin.py#L207
		}
		else {
			_error("Error parsing BMP! (uknown compression type {})".fmt([biCompression]))
		}

		biTile = [
			raw_mode,
			$.floor((biWidth * biBitCount + 31).s_right(3) / 4) * 4,
		]

		return @bmp_fhdr::{
			size,
			biYFlip,
			biDirection,
			biWidth,
			biHeight,
			biPlanes,
			biBitCount,
			biCompression,
			biImageSize,
			biPixPerMeter,
			biColors,
			biPalettePadding,
			biDpi,
			biRGBMask,
			biRGBAMask,
			biMode,
			biTile
		}
	}
}

type @bmp_palette
impl @bmp_palette {

	new: (data: [@number], mode: @string) {
		let colours = []

		len = (data.length / 4)

		for i in 0..len {
			//Skip the 4th index since it's usually reserved
			//It's in BGR order
			colours.push(@colour::new(data[i*4+2], data[i*4+1], data[i*4]))
		}

		return @bmp_palette::{
			colours,
		}
	}
}

type @bmp_csec
impl @bmp_csec {

	new: (file_header, info_header, data: @data) {
		let data = data
		let palette = null

		let mode = info_header.biMode

		if info_header.biMode == "P" {
			if info_header.biColors < 0 || info_header.biColors > 65536 {
				_error("Error parsing BMP! (unsupported palette size {})".fmt([info_header.biColors]))
			}
			else {
				let greyscale = true

				padding = info_header.biPalettePadding
				palette = data.read(padding * info_header.biColors).raw()
				indicies = [0, 255] if info_header.biColors == 2 else (0..info_header.biColors) as @array

				for i in 0..indicies.length {
					val = indicies[i]

					rgb = palette[i * padding : i * padding + 3]

					if rgb.sum() != (val.b_and(255)) * 3 {
						greyscale = false
					}
				}

				if greyscale {
					// TODO: Test >1bit greyscale bitmaps
					mode = "G" if info_header.biColors == 2 else raw_mode
				}
				else {
					palette = @bmp_palette::new(palette, "BGRX" if padding == 4 else "BGR")
				}
			}
		}

		pix_data_len = info_header.biTile[1] * info_header.biHeight
		
		//Move back to the start
		data.move(-data.p)
		//Use the defined offset to get to the data because it is possible there is a gap between the colour table and pixel data
		data.move(file_header.bfOffBits)

		let pix_data = data.read(pix_data_len)

		//TODO: test y flipped bmps

		let read = []

		let padding = $.floor(4 - ((info_header.biWidth * info_header.biBitCount / 8) % 4))
		padding = padding if padding != 4 else 0

		//Im sure theres a much better way of doing this lol
		while !pix_data.is_eof() {
			let bytes = pix_data.read(info_header.biTile[1] - padding).raw()
			let b = []
			
			//1 bit monochrome / indexed BMP
			if info_header.biBitCount == 1 {
				bytes = bytes.map((b) => b.to_bin()).flatten()

				//1 bit is 1 pixel
				for i in 0..bytes.length {
					if i >= info_header.biWidth {
						break
					}
					b.push(bytes[i])
				}
			}
			//4 bit indexed BMP
			else if info_header.biBitCount == 4 {
				bytes = bytes.map((b) => b.to_bin()).flatten()

				//1 nibble is 1 pixel
				for i in 0..4..bytes.length - 4 {
					if i / 4 >= info_header.biWidth {
						break
					}
					//to_bin will return in big endian format so we need to specify big endian when converting it back to an int
					b.push(bytes[i:i+4].binary_to_int())
				}
			}
			//8 bit indexed BMP
			else if info_header.biBitCount == 8 {
				bytes = bytes.map((b) => b.to_bin())

				//Custom enumerate function :)
				enumerate(bytes, (i, byte, end) {
					if i >= info_header.biWidth {
						end()
					}
					b.push(byte.binary_to_int())
				})

			}
			//16 bit true colour BMP (RGB555[1] / RGB565)
			else if info_header.biBitCount == 16 {
				bytes = @data::new(bytes.map((b) => b.to_bin()).flatten())

				to_8_bit = (val) {
					return (val * 255) / 31
				}

				for i in 0..(bytes.length / 16) {
					blue = to_8_bit(bytes.read(5).raw().binary_to_int())
					let green = null
					let red = null

					//Indicates RGB 565
					if info_header.biRGBAMask.length > 0 || info_header.biRGBMask.length > 0 {
						green = to_8_bit(bytes.read(6).raw().binary_to_int())
						red = to_8_bit(bytes.read(5).raw().binary_to_int())
					}
					//RGB 555[1]
					else {
						green = to_8_bit(bytes.read(5).raw().binary_to_int())
						red = to_8_bit(bytes.read(5).raw().binary_to_int())
						bytes.move(1)
					}

					b.push(@colour::new(red, green, blue))
				}
			}
			//24 bit true colour BMP
			else if info_header.biBitCount == 24 {
				for i in 0..3..bytes.length - 3 {
					//Convert into colour instances - format is BRG
					b.push(@colour::new(bytes[i:i+3][2], bytes[i:i+3][1], bytes[i:i+3][0]))
				}
			}
			//32 bit true colour BMP (RBG / RGBA)
			else if info_header.biBitCount == 32 {
				for i in 0..4..bytes.length - 4 {
					//Convert into colour instances - format is BRG
					b.push(@colour::new(bytes[i:i+4][2], bytes[i:i+4][1], bytes[i:i+4][0], a=bytes[i:i+4][3]))
				}
			}

			read.push(b)
			pix_data.move(padding)
		}

		$.print(read)

		return @bmp_csec::{
			palette,
			read,
			mode,
		}	
	}
}

type @bmp
impl @bmp {
	HEADER: "BM",

	_parse: (self) {
		file_header = @bmp_fhdr::new(self.raw)
		self.raw.move(file_header.size)

		self.fhdr = file_header

		if @bmp::HEADER != file_header.bfType {
			_error("Invalid BMP file! (incorrect file header \"{}\")".fmt(file_header.bfType))
		}

		info_header = @bmp_ihdr::new(self.raw)
		self.raw.move(info_header.size)

		self.ihdr = info_header

		self.col = @bmp_csec::new(self.fhdr, self.ihdr, self.raw)

		self.raw = null
	},

	pixel_at: (self, x: @number, y: @number) {
		return self.col.at(x, y)
	},

	new: (data: @data) {

		return @bmp::{
			fhdr: null,
			ihdr: null,
			col: null,
			raw: data
		}
	}
}


//Reads and parses the bmp file
parse_bmp = (
	#[desc("Path to the file")]
	file,
) {
    let data = @data::new($.readfile(file, "bin"))

	let bmp = @bmp::new(data)
	bmp._parse()

	return bmp
}



bmp_to_objects = (
	#[desc("Starting x offset for the pixels. Default is 5 blocks (from 0,0)")]
	start_x = 10,
	#[desc("Starting y offset for the pixels. Default is 50 blocks (from 0,0)")]
	start_y = 100,

	#[desc("Starting group for the objects. Default is 1")]
	start_group = 1,
	#[desc("Enables/Disables adding groups to all the pixels. Default is false")]
	add_groups = false,
	#[desc("The function that generates the group value. Overrides \"add_groups\"")]
	group_factory = null,

	#[desc("Instead of using 1 unique colour for every pixel, use 1 colour and hue shift to get the right colour. Default is false")]
	use_hue_shift = false,
	#[desc("Starting hue offset. Default is 0")]
	hue_offset = 0,

	#[desc("The size of the individual pixels. Default is 1")]
	pixel_scale = 1,
	#[desc("The number of pixels placed per pixel in the image (n:1). Default is 1")]
	pixel_density = 1,

	#[desc("Enables/Disables glow on the pixels. Default is false")]
	show_glow = false,
) {
	//Validation for the arguments
	if start_x <= 0 {
		_error("start_x must be greater than 0!")
	}
	if start_y <= 0 {
		_error("start_y must be greater than 0!")
	}

	if start_group <= 0 {
		_error("start_group must be greater than 0!")
	}

	if hue_offset < 0 || hue_offset > 180 {
		_error("hue_offset must be between 0 and 180!")
	}

	if pixel_scale < 0.1 || pixel_scale > 4 {
		_error("pixel_scale must be between 0.1 and 4!")
	}
}

parse_bmp("16bit5551.bmp")
