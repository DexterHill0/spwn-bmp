extract import "utils.spwn"

PIXEL_OBJ_ID = null

_error = (message) {
	throw "[ERROR]: {}".fmt([message])
}

type @bmp_csec
impl @bmp_csec {

	MODES: {
		//The valid bit depths for each mode
		INDEXED: [1, 4, 8],
		TRUE_COL: [16, 24, 32]
	},
	
	new: (mode: @number, pix_off: @number, data: @data) {
		let data = data

		let pal_cols = null
		let pixels = null

		if @bmp_csec::MODES.INDEXED has mode {
			//Get the length of the colour palette index thingy
			pal_index = data.length - pix_off

			pal_cols = data.read(pal_index)
			pixels = data.read(pix_off)
		}
		else if @bmp_csec::MODES.TRUE_COL has mode {
			//Data is already the pixel data since there is no palette in true colour
			pixels = data
		}
		else {
			_error("Error parsing BMP (invalid bit depth {})".fmt([mode]))
		}

		return @bmp_csec::{
			mode: mode,
			pal: pal_cols,
			pix: pixels,
		}
	}
}

//Moved into separate classes since it's just a bit neater
type @bmp_fhdr
impl @bmp_fhdr {
	SIZE: 14,

	new: (data: @data) {
		let data = data

		let file_header = data.read(@bmp_fhdr::SIZE)
		
		bfType = file_header.read(2).raw().bytes_to_str()
		bfSize = file_header.read(4).raw().bytes_to_int()
		
		//Skip reserved
		file_header.move(4)

		bfOffBits = file_header.read(4).raw().bytes_to_int()

		return @bmp_fhdr::{
			size: @bmp_fhdr::SIZE,
			bfType,
			bfSize,
			reserved1: 0,
			reserved2: 0,
			bfOffBits,
		}
	}
}

type @bmp_ihdr
impl @bmp_ihdr {
	new: (data: @data) {
		let data = data

		size = data.read(4).raw().bytes_to_int()

		let info_header = data.read(size)
		
		biWidth = info_header.read(4).raw().bytes_to_int()
		biHeight = info_header.read(4).raw().bytes_to_int()

		//Skips `biPlanes`
		info_header.move(2)

		biBitCount = info_header.read(2).raw().bytes_to_int()
		biCompression = info_header.read(4).raw().bytes_to_int()
		biSizeImage = info_header.read(4).raw().bytes_to_int()

		return @bmp_fhdr::{
			size,
			biWidth,
			biHeight,
			biPlanes: 1,
			biBitCount,
			biCompression,
			biSizeImage,
		}
	}
}

type @bmp
impl @bmp {
	HEADER: "BM",

	_parse: (self) {
		file_header = @bmp_fhdr::new(self.raw)
		self.raw.move(file_header.size)

		if @bmp::HEADER != file_header.bfType {
			_error("Invalid BMP file! (incorrect file header)")
		}

		info_header = @bmp_ihdr::new(self.raw)
		self.raw.move(info_header.size)

		self.inf = {
			w: info_header.biWidth,
			h: info_header.biHeight,
		}

		//biSizeImage is used if the BMP is in true colour and it specifies the size of pixel data
		//If the BMP is in indexed colour, the rest of the data is used
		data_size = info_header.biSizeImage if info_header.biSizeImage > 0 else self.raw.length

		self.col = @bmp_csec::new(
			info_header.biBitCount,
			//bfOffBits (p_off) is relative to the start of the file so I need to subtract the length that I have already read
			file_header.bfOffBits - file_header.size - info_header.size, 
			self.raw.read(data_size)
		)


		self.raw = null
	},

	new: (data: @data) {

		return @bmp::{
			inf: {
				w: null,
				h: null,
			},
			col: null,
			raw: data
		}
	}
}


//Reads and parses the bmp file
parse_bmp = (
	#[desc("Path to the file")]
	file,
) {
    let data = @data::new($.readfile(file, "bin"))

	let bmp = @bmp::new(data)
	bmp._parse()

	return bmp
}



bmp_to_objects = (
	#[desc("Starting x offset for the pixels. Default is 5 blocks (from 0,0)")]
	start_x = 10,
	#[desc("Starting y offset for the pixels. Default is 50 blocks (from 0,0)")]
	start_y = 100,

	#[desc("Starting group for the objects. Default is 1")]
	start_group = 1,
	#[desc("Enables/Disables adding groups to all the pixels. Default is false")]
	add_groups = false,
	#[desc("The function that generates the group value. Overrides \"add_groups\"")]
	group_factory = null,

	#[desc("Instead of using 1 unique colour for every pixel, use 1 colour and hue shift to get the right colour. Default is false")]
	use_hue_shift = false,
	#[desc("Starting hue offset. Default is 0")]
	hue_offset = 0,

	#[desc("The size of the individual pixels. Default is 1")]
	pixel_scale = 1,
	#[desc("The number of pixels placed per pixel in the image (n:1). Default is 1")]
	pixel_density = 1,

	#[desc("Enables/Disables glow on the pixels. Default is false")]
	show_glow = false,
) {
	//Validation for the arguments
	if start_x <= 0 {
		_error("start_x must be greater than 0!")
	}
	if start_y <= 0 {
		_error("start_y must be greater than 0!")
	}

	if start_group <= 0 {
		_error("start_group must be greater than 0!")
	}

	if hue_offset < 0 || hue_offset > 180 {
		_error("hue_offset must be between 0 and 180!")
	}

	if pixel_scale < 0.1 || pixel_scale > 4 {
		_error("pixel_scale must be between 0.1 and 4!")
	}
}

// 1.bmp = average bmp (true colour)
// 2.bmp = indexed colour bmp
//


parse_bmp("2.bmp")
