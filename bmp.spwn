extract import "utils.spwn"

PIXEL_OBJ_ID = null

_error = (message) {
	throw "[ERROR]: {}".fmt([message])
}

type @colour
impl @colour {

	new: (r: @number, g: @number, b: @number, a: @number = 1) {
		return @colour::{
			r, g, b, a
		}
	}
}


//Moved into separate classes since it's just a bit neater
type @bmp_fhdr
impl @bmp_fhdr {
	SIZE: 14,

	new: (data: @data) {
		let data = data

		let file_header = data.read(@bmp_fhdr::SIZE)
		
		bfType = file_header.read(2).raw().bytes_to_str()
		bfSize = file_header.read(4).raw().bytes_to_int()
		
		//Skips reserved
		file_header.move(4)

		bfOffBits = file_header.read(4).raw().bytes_to_int()

		return @bmp_fhdr::{
			size: @bmp_fhdr::SIZE,
			bfType,
			bfSize,
			reserved1: 0,
			reserved2: 0,
			bfOffBits,
		}
	}
}

// https://github.com/python-pillow/Pillow/blob/master/src/PIL/BmpImagePlugin.py
// ^^^ very helpful :)
type @bmp_ihdr
impl @bmp_ihdr {
	
	BIT2MODE: @enum::new([
		["P", "P;1"],
		["P", "P;4"],
		["P", "P"],
		["RGB", "BGR;15"],
		["RGB", "BGR"],
		["RGB", "BGRX"]
	], [1, 4, 8, 16, 24, 32]),

	SUPPORTED: @enum::new([
		[
			[16711680, 65280, 255, 0],
			[16711680, 65280, 255, 4278190080],
			[255, 65280, 16711680, 4278190080],
			[0, 0, 0, 0],
			[4278190080, 16711680, 65280, 0],
		],	
		[[16711680, 65280, 255]],
		[[63488, 2016, 31], [31744, 992, 31]],
	], [32, 24, 16]),

	MASK_MODES: {
		// -> _<bitCount>_<SUPPORTED-arrayIndex>
		_32_0: "BGRX",
		_32_1: "XBGR",
		_32_2: "RGBA",
		_32_3: "BGRA",
		_32_4: "BGRA",
		_24_0: "BGR",	
		_16_0: "BGR;16",
		_16_1: "BGR;15",
	},

	COMPRESSIONS: @enum::new(["RAW", "RLE8", "RLE4", "BITFIELDS"]),

	new: (data: @data) {
		let data = data

		size = data.read(4).raw().bytes_to_int()

		//Oops >.<
		let biWidth = null; let biHeight = null; let biPlanes = null; let biBitCount = null; let biCompression = null; let biPalettePadding = null;
		let biYFlip = null; let biDirection = null; let biImageSize = null; let biPixPerMeter = null; let biColors = null; let biDpi = [];

		//IBM OS/2 Bitmap v1
		if size == 12 {
			let info_header = data.read(size - 4)

			biWidth = info_header.read(2).raw().bytes_to_int()
			biHeight = info_header.read(2).raw().bytes_to_int()
			biPlanes = info_header.read(2).raw().bytes_to_int()
			biBitCount = info_header.read(2).raw().bytes_to_int()
			biCompression = @bmp::COMPRESSIONS.."RAW"
			biPalettePadding = 3

		}
		//Windows Bitmap v2 to v5
		else if [40, 64, 108, 124] has size {
			let info_header = data.read(size - 4)

			biYFlip = (info_header.raw()[7] == 255)
			biDirection = 1 if biYFlip else -1

			biWidth = info_header.read(4).raw().bytes_to_int()
			biHeight = info_header.read(4).raw().bytes_to_int()
			biHeight = biHeight if !biYFlip else 2 ** 32 - biHeight

			biPlanes = info_header.read(2).raw().bytes_to_int()
			biBitCount = info_header.read(2).raw().bytes_to_int()
			biCompression = info_header.read(4).raw().bytes_to_int()
			biImageSize = info_header.read(4).raw().bytes_to_int()
			biPixPerMeter = [
				info_header.read(4).raw().bytes_to_int(),
				info_header.read(4).raw().bytes_to_int(),
			]

			biColors = info_header.read(4).raw().bytes_to_int()
			biPalettePadding = 4

			for m in biPixPerMeter {
				biDpi.push($.floor(m / 39.3701 + 0.5))
			}

		}
		else {
			_error("Error parsing BMP! (unknown header type {})".fmt([size]))
		}

		biColors = biColors if biColors != 0 else 1.s_left(biBitCount)
		
		let masks = {}
		let biRGBMask = []
		let biRGBAMask = []

		if @bmp_ihdr::COMPRESSIONS.."BITFIELDS" == biCompression {
			_m = ["r_mask", "g_mask", "b_mask", "a_mask"]
			if size >= 52 {
				for i in 0.._m.length {
					masks.set(_m[i], info_header.read(36 + i * 4).raw().bytes_to_int())
				}
			} 
			else {
				masks["a_mask"] = 0
				
				//Leave out a_mask
				for m in _m[0:3] {
					masks.set(m, data.read(4).raw().bytes_to_int())
				}
			}

			biRGBAMask = [
				masks["r_mask"],
				masks["g_mask"],
				masks["b_mask"],
				masks["a_mask"],
			]
			biRGBMask = [
				masks["r_mask"],
				masks["g_mask"],
				masks["b_mask"],
			]
		}

		mask_key = (bit, ind) {
			return "_{}_{}".fmt([bit, ind])
		}

		modes = @bmp_ihdr::BIT2MODE..biBitCount
		let biMode = modes[0]
		let raw_mode = modes[1]
		
		if @bmp_ihdr::COMPRESSIONS.."BITFIELDS" == biCompression {
			if @bmp_ihdr::SUPPORTED has biBitCount {
				if biBitCount == 32 && ((@bmp_ihdr::SUPPORTED..biBitCount) has biRGBAMask) {
					raw_mode = @bmp_ihdr::MASK_MODES[mask_key(biBitCount, (@bmp_ihdr::SUPPORTED..biBitCount).index(biRGBAMask))]
					biMode = "RGBA" if raw_mode has "A" else biMode
				}
				else if [24, 16] has biBitCount && ((@bmp_ihdr::SUPPORTED..biBitCount) has biRGBMask) {
					raw_mode = @bmp_ihdr::MASK_MODES[mask_key(biBitCount, (@bmp_ihdr::SUPPORTED..biBitCount).index(biRGBMask))]
				}
				else {
					_error("Error parsing BMP! (uknown bitfields layout)")
				}
			}
			else {
				_error("Error parsing BMP! (uknown bitfields layout)")
			}
		}
		else if @bmp_ihdr::COMPRESSIONS.."RAW" == biCompression {
			// According to PIL this branch checks a variable called "header" to see if it is `22`
			// but "header" is never provided as an argument to the func so I dont think this branch ever executes
			// https://github.com/python-pillow/Pillow/blob/fb0aad5abdab9027cf8f02082ca4dab921692b79/src/PIL/BmpImagePlugin.py#L207
		}
		else {
			_error("Error parsing BMP! (uknown compression type {})".fmt([biCompression]))
		}

		biTile = [
			raw_mode,
			data.p,
			//TODO: proper binary AND

			//((biWidth * biBitCount + 31).s_right(3)).b_and(-4),
		]

		return @bmp_fhdr::{
			size,
			biYFlip,
			biDirection,
			biWidth,
			biHeight,
			biPlanes,
			biBitCount,
			biCompression,
			biImageSize,
			biPixPerMeter,
			biColors,
			biPalettePadding,
			biDpi,
			biRGBMask,
			biRGBAMask,
			biMode,
			biTile
		}
	}
}

type @bmp_csec
impl @bmp_csec {

	new: (file_header, info_header, data: @data) {
		let data = data
		let palette = null

		if info_header.biMode == "P" {
			if info_header.biColors < 0 || info_header.biColors > 65536 {
				_error("Error parsing BMP! (unsupported palette size {})".fmt([info_header.biColors]))
			}
			else {
				padding = info_header.biPalettePadding
				palette = data.read(padding * info_header.biColors).raw()
				let greyscale = true
				indicies = [0, 255] if info_header.biColors == 2 else (0..info_header.biColors) as @array

				for i in 0..indicies.length {
					val = indicies[i]

					rgb = palette[i * padding : i * padding + 3]

					if rgb != ((val.b_and(255)) * 3) {
						greyscale = false
					}
				}
			}
		}

		return @bmp_csec::{
			palette,
		}
		
	}
}

type @bmp
impl @bmp {
	HEADER: "BM",

	_parse: (self) {
		file_header = @bmp_fhdr::new(self.raw)
		self.raw.move(file_header.size)

		self.fhdr = file_header

		if @bmp::HEADER != file_header.bfType {
			_error("Invalid BMP file! (incorrect file header \"{}\")".fmt(file_header.bfType))
		}

		info_header = @bmp_ihdr::new(self.raw)
		self.raw.move(info_header.size)

		self.ihdr = info_header

		self.col = @bmp_csec::new(self.fhdr, self.ihdr, self.raw)

		self.raw = null
	},

	pixel_at: (self, x: @number, y: @number) {
		return self.col.at(x, y)
	},

	new: (data: @data) {

		return @bmp::{
			fhdr: null,
			ihdr: null,
			col: null,
			raw: data
		}
	}
}


//Reads and parses the bmp file
parse_bmp = (
	#[desc("Path to the file")]
	file,
) {
    let data = @data::new($.readfile(file, "bin"))

	let bmp = @bmp::new(data)
	bmp._parse()

	return bmp
}



bmp_to_objects = (
	#[desc("Starting x offset for the pixels. Default is 5 blocks (from 0,0)")]
	start_x = 10,
	#[desc("Starting y offset for the pixels. Default is 50 blocks (from 0,0)")]
	start_y = 100,

	#[desc("Starting group for the objects. Default is 1")]
	start_group = 1,
	#[desc("Enables/Disables adding groups to all the pixels. Default is false")]
	add_groups = false,
	#[desc("The function that generates the group value. Overrides \"add_groups\"")]
	group_factory = null,

	#[desc("Instead of using 1 unique colour for every pixel, use 1 colour and hue shift to get the right colour. Default is false")]
	use_hue_shift = false,
	#[desc("Starting hue offset. Default is 0")]
	hue_offset = 0,

	#[desc("The size of the individual pixels. Default is 1")]
	pixel_scale = 1,
	#[desc("The number of pixels placed per pixel in the image (n:1). Default is 1")]
	pixel_density = 1,

	#[desc("Enables/Disables glow on the pixels. Default is false")]
	show_glow = false,
) {
	//Validation for the arguments
	if start_x <= 0 {
		_error("start_x must be greater than 0!")
	}
	if start_y <= 0 {
		_error("start_y must be greater than 0!")
	}

	if start_group <= 0 {
		_error("start_group must be greater than 0!")
	}

	if hue_offset < 0 || hue_offset > 180 {
		_error("hue_offset must be between 0 and 180!")
	}

	if pixel_scale < 0.1 || pixel_scale > 4 {
		_error("pixel_scale must be between 0.1 and 4!")
	}
}

parse_bmp("24bit_top-bottom.bmp")
