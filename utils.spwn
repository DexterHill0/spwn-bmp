extract import "ascii.spwn"

//enum-ish thingy
//uses the range operator (..) to allow "indexing" of the enum
type @enum
impl @enum {

	_range_: (self, text) {
		if text == null {
			return
		}

		if $.matches(text, @string) {
			//Have to loop through the values since .values() will return the values in a random order each time.
			for k in self.e.keys() {
				if self.e[k] == text {
					return k.l_trim(["_"]) as @number;
				}
			}
		}
		else {
			return self.e["_{}".fmt([text])]
		}
	},

	_has_: (self, other: @number) {
		if other == null {
			return false
		}

		return self.e.keys().index("_{}".fmt([other])) != null
	},

	new: (values, nums = []) {
		let e = {}

		for i in 0..values.length {
			if nums.length > 0 {
				e.set("_{}".fmt([nums[i]]), values[i])
			}
			else {
				e.set("_{}".fmt([i]), values[i])
			}
		}

		return @enum::{
			e,
		}
	}
}

type @data
impl @data {
	read: (self, amount: @number) {
		let data = @data::new(self.d[self.p : self.p+amount])
		self.p += amount
		return data
	},

	move: (self, pos: @number) {
		self.p += pos
	},

	raw: (self) {
		return self.d
	},

	is_eof: (self) {
		return self.p >= self.d.length
	},

	new: (data: [@number]) {
		return @data::{
			d: data,
			length: data.length,
			p: 0
		}
	}
}

impl @array {
	//Takes array of bytes and converts them to an integer
	bytes_to_int: (self) {
		return self.reverse().reduce((acum, el) => (acum * 256) + el)
	},

	//Takes array of bytes and converts them to a string
	bytes_to_str: (self) {
		return "".join(self.map((i) => chr(i)))
	},
	
}

impl @number {
	//Bitwise left shift
	s_left: (self, amount: @number) {
		return self * (2 ^ amount)
	},

	//Bitwise right shift
	s_right: (self, amount: @number) {
		return self / (2 ^ amount)
	},
	
	//Bitwise AND
	//Im sure theres a more efficient way but whatever it works
	b_and: (self, val: @number) {
		
	},
}

return {
	data: @data,
	enum: @enum,
}
