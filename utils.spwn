extract import "ascii.spwn"

//enum-ish thingy
//uses the range operator (..) to allow "indexing" of the enum
type @enum
impl @enum {

	_range_: (self, text) {
		if text == null {
			return
		}

		if $.matches(text, @string) {
			//Have to loop through the keys since .values() will return the values in a random order each time and the order
			//of an enum is *very* important
			for k in self.e.keys() {
				if self.e[k] == text {
					return k.l_trim(["_"]) as @number;
				}
			}
		}
		else {
			return self.e["_{}".fmt([text])]
		}
	},

	_has_: (self, other: @number) {
		if other == null {
			return false
		}

		return self.e.keys().index("_{}".fmt([other])) != null
	},

	new: (values, nums = []) {
		let e = {}

		for i in 0..values.length {
			if nums.length > 0 {
				e.set("_{}".fmt([nums[i]]), values[i])
			}
			else {
				e.set("_{}".fmt([i]), values[i])
			}
		}

		return @enum::{
			e,
		}
	}
}

type @data
impl @data {
	read: (self, amount: @number) {
		let data = @data::new(self.d[self.p : self.p+amount])
		self.p += amount
		return data
	},

	move: (self, pos: @number) {
		self.p += pos
	},

	raw: (self) {
		return self.d
	},

	is_eof: (self) {
		return self.p >= self.d.length
	},

	new: (data: [@number]) {
		return @data::{
			d: data,
			length: data.length,
			p: 0
		}
	}
}

impl @array {
	//Takes array of bytes and converts them to an integer
	bytes_to_int: (self) {
		return self.reverse().reduce((acum, el) => (acum * 256) + el)
	},

	//Takes array of bytes and converts them to a string
	bytes_to_str: (self) {
		return "".join(self.map((i) => chr(i)))
	},
	
}

num_to_bin = (n: @number, bits: @number) {
    let digits = []
    let val = $.abs(n)
    for i in bits..0 {
        x = 2^i
        if val >= x {
            val -= x
            digits.push(true)
        } else {
            digits.push(false)
        }
    }

    return digits.reverse()
}

bin_to_num = (bin: [@bool]) {
	let sum = 0
	for i in 0..bin.length {
		if bin[i] {
			sum += 2 ^ i
		}
	}
	return sum
}


impl @number {
	//Bitwise left shift
	s_left: (self, amount: @number) {
		return self * (2 ^ amount)
	},

	//Bitwise right shift
	s_right: (self, amount: @number) {
		return self / (2 ^ amount)
	},
	
	//Bitwise AND
	b_and: (self, val: @number) {
		let v1 = num_to_bin(self, 16)
		let v2 = num_to_bin(val, 16)

		for i in 0..v1.length {
			v1[i] = v1[i] && v2[i]
		}

		return bin_to_num(v1)
	},
}

return {
	data: @data,
	enum: @enum,
}
