extract import "ascii.spwn"

//enum-ish thingy
//uses the range operator (..) to allow "indexing" of the enum
type @enum
impl @enum {

	_range_: (self, text) {
		if text == null {
			return
		}

		if $.matches(text, @string) {
			//Have to loop through the keys since .values() will return the values in a random order each time and the order
			//of an enum is *very* important
			for k in self.e.keys() {
				if self.e[k] == text {
					return k.l_trim(["_"]) as @number;
				}
			}
		}
		else {
			return self.e["_{}".fmt([text])]
		}
	},

	_has_: (self, other: @number) {
		if other == null {
			return false
		}

		return self.e.keys().index("_{}".fmt([other])) != null
	},

	new: (values, nums = []) {
		let e = {}

		for i in 0..values.length {
			if nums.length > 0 {
				e.set("_{}".fmt([nums[i]]), values[i])
			}
			else {
				e.set("_{}".fmt([i]), values[i])
			}
		}

		return @enum::{
			e,
		}
	}
}

type @data
impl @data {
	read: (self, amount: @number) {
		let data = @data::new(self.d[self.p : self.p+amount])
		self.p += amount
		return data
	},

	move: (self, pos: @number) {
		self.p += pos
	},

	raw: (self) {
		return self.d
	},

	is_eof: (self) {
		return self.p >= self.d.length
	},

	new: (data: [@number]) {
		return @data::{
			d: data,
			length: data.length,
			p: 0
		}
	}
}

impl @array {
	//Takes array of bytes and converts them to an integer
	bytes_to_int: (self) {
		//Needs to be reversed since BMPs are little endian
		return self.reverse().reduce((acum, el) => (acum * 256) + el)
	},

	//Takes array of bytes and converts them to a string
	bytes_to_str: (self) {
		return "".join(self.map((i) => chr(i)))
	},

	binary_to_int: (self) {
		let sum = 0
		for i in 0..self.length {
			if self[i] == 1 {
				sum += 2 ^ i
			}
		}
		return sum
	},

	fill: (self, amount, value) {
		nums = "".r_pad(amount + 1, "{},".fmt([value])).split(",")[0:amount].map((val) => val as @number)

		return nums
	}
}


impl @number {
	//Bitwise left shift
	s_left: (self, amount: @number) {
		return self * (2 ^ amount)
	},

	//Bitwise right shift
	s_right: (self, amount: @number) {
		return self / (2 ^ amount)
	},

	to_bin: (self, bits=8) {
		let digits = []
		let val = $.abs(self)
		for i in bits..0 {
			x = 2 ** i
			if val >= x {
				val -= x
				digits.push(1)
			} else {
				digits.push(0)
			}
		}
		return digits.reverse()
	},
	
	//Bitwise AND
	b_and: (self, val: @number) {
		let v1 = self.to_bin(16)
		let v2 = val.to_bin(16)

		for i in 0..v1.length {
			v1[i] = (v1[i] as @bool) && (v2[i] as @bool)
		}

		return v1.binary_to_int()
	},
}

enumerate = (iterator, callback) {
	let index = 0
	let cont = true
	while cont && index < iterator.length - 1 {
		end = () { cont = false }
		callback(index, iterator[index], end)
		index++
	}
}


return {
	data: @data,
	enum: @enum,
	enumerate,
}
